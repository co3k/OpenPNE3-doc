=========================================
OpenPNE3 セキュアコーディングガイドライン
=========================================

目次
====

.. contents::

概要
====

このドキュメントは、セキュリティを前提としたコーディングをおこなうために従うべきガイドラインを、 OpenPNE3 に貢献する個人またはチームに示すためのものです。

ユーザをなりすましから守る
==========================

セッション管理
--------------

セッションとは
++++++++++++++

HTTP はステートレスな通信プロトコルであり、 1 回のリクエストに対応するレスポンスが完了した段階で通信も終了します。これはつまり、レスポンスをおこなうための情報はすべてリクエストによって都度提供されなくてはならないということを意味します。 HTTP のこの特性は、 Web アプリケーションにおいては都合が悪いことがあります。

EC サイトでの商品購入までのやり取りがその好例です。取引が複数の画面にまたがっておこなわれる場合、商品をカートに入れたクライアントと決済を確定するまでのクライアントが同一のものであることを確実にしておく必要があります。別のクライアントが選択した商品が誤ってカートに入ってしまったり、他人のショッピングカートに対して決済処理を実行できてしまってはいけません。

このように、特定のクライアントからの複数の HTTP リクエストをひとまとまりのものとしてみなす必要が生じることがあります。ここで登場するのがセッションの概念です。ステートフルなプロトコルでは、一般に、サーバとクライアントとの複数回にわたる相互のやりとりをおこなうために確立させた接続の開始から切断までが一つのセッションとして扱われます。 HTTP では都度接続が切断されてしまうため、サーバソフトウェアの機能などを利用し、アプリケーション側でセッション管理を実現しています。 Web アプリケーション等の文脈においては、このひとまとまりの処理や、そのためにクライアントを識別可能な状態にしておくことを「セッション」と呼ぶことがあります。

セッションデータとセッション ID
+++++++++++++++++++++++++++++++

HTTP サーバソフトウェアやミドルウェアは、そのセッションを一定期間特定するために「セッション ID」と呼ばれる識別子をセッションに付与し、そのセッション ID をクライアントに通知します。サーバから与えられたセッション ID をリクエストに含むことによって、現在の通信はどのセッションであるのかをサーバ側で識別することができます。

ただし、セッション ID だけでは、そのクライアントがそのセッションにおいてどういう状態 (EC サイトであれば、ショッピングカートに何を入れているか、商品購入のどのフェーズにいるのか……など) にあるのかということを判別することができません。そこで、サーバは、セッション ID に紐付いた付加情報を併せて保持しておくことが求められます。

セッションデータに保存する情報は、リクエストに含まれる情報と違い、クライアントが自由に操作できてはいけない場合があります。セッションデータに情報を格納しておくべき状況として、そのセッションに紐付いたユーザを特定し続けるために、セッションデータにユーザ名を入れておくといったものが考えられます。これを、たとえば、 Cookie 等に平文のユーザ名を含んで同じことを実現しようとした場合、その情報はクライアントが自由に操作することができるので、たとえば自分以外のユーザ名を Cookie に含み、そのユーザになりすましてしまえるといったことがおこりえます。

また、セッション ID についても、たとえば連番などの予測可能なものであったり、容易に漏洩してしまったりすると、そのセッション ID をリクエストして他人の通信に用いられているセッションを不正に利用されかねません。そのため、セッション ID の取り扱いには充分に注意する必要があります。

セッションを使用して認証を実現する
++++++++++++++++++++++++++++++++++

ログインを必要とするアプリケーションでは、このセッションの仕組みを利用して認証を実現しているものがあります。 OpenPNE も例外ではありません。

OpenPNE では、ログインからログアウトまでをひとつのセッションとし、ログインを必要とするページへのアクセスは、そのセッションを有しているクライアントにだけ許可しています。セッションデータにはメンバー ID が格納されており、そのセッションが有効な間、クライアントはそのメンバー ID のメンバーとしてアクセスし続けることになります。

Session Hijaking
++++++++++++++++

Session Hijaking とは、悪意を持ったユーザが、第三者のセッション ID を何らかの方法で入手し、そのセッション ID を使用して他人になりすます等をする攻撃です。

そのため、セッション ID は他人に知られないように充分な配慮をしなければなりません。

 * セッション ID は推測可能なものであってはなりません。たとえば、 ID が連番など規則性のあるものであっては、容易にセッション ID を推測し、なりすますことが可能になってしまいます。
    * そのため、セッション ID として使う文字列は乱数が適していると言えます。ただし、乱数は暗号論的擬似乱数 (予測不可能性がある関数) により生成する必要があります。たとえば、 PHP の mt_rand() で使われる Mersenne twister のアルゴリズムにより生成される乱数は予測可能性があるため、この用途には適していません。たとえば、 /dev/urandom などを利用して乱数を生成するべきです。
 * セッション ID は充分な長さを持っていなければなりません。ブルートフォースアタックによって有効な ID を割り出すことが可能になってしまいます。
 * セッション ID は漏洩しないよう気を配らねばなりません。 URL パラメータにセッション ID を含むことによりログインを継続する形式の場合、利用者が無自覚に他人にその URL を教えてしまった場合や、リファラを経由して、セッション ID が第三者に知られてしまうことになるので避けるべきです。 Cookie の利用できない携帯電話への考慮をおこなうなど、セッション ID を URL に含まざるを得ない場合は、外部サイトへの直接のリンクをおこなわない (= 外部サイトにリファラ経由でセッション ID を送信してしまわないようにする) などの努力をおこなわなければなりません。
 * セッション ID が知られてしまったときの配慮も充分におこなうようにしてください。特にセッション ID を URL に含まざるを得ない場合などは、セッション ID の有効期限を短くしたり、ログイン時のユーザエージェント文字列と現在のユーザエージェント文字列が一致しているかどうかの確認をおこなうようにしてください。

OpenPNE では、 PHP 標準のセッション管理機構 (http://jp2.php.net/manual/ja/book.session.php) を利用してセッション管理をおこなっています。 PHP のセッション管理機構では、セッション ID の生成や、セッションデータの管理などがおこなえるようになっています。デフォルトのセッションストレージはファイルシステムですが、 Web サーバの並列化をする場合など、セッションストレージがファイルシステムでは都合が悪い場合があります。その場合も、独自のセッション管理機構を作成するなどせず、かならずカスタムセッションハンドラ (http://jp2.php.net/manual/ja/session.customhandler.php) に則って実現するようにしてください (なお、 OpenPNE では、このカスタムセッションハンドラを用いて、データベースおよび Memcached をセッションストレージとして使用できるようになっています)。

PHP では、 session_id() 関数に第一引数を渡すことによって、 PHP の生成したセッション ID 以外の、自分で生成した文字列をセッション ID として用いることができるようになっていますが、乱数以外の文字列や、予測可能性のある乱数生成アルゴリズムによって生成された乱数を使用してしまわないようにしてください。そのような文字列を生成することができないのであれば、 PHP の生成したセッション ID をそのまま使用するようにしてください。

また、これらのセッションハンドリング関連処理は symfony や OpenPNE によって抽象化されています。独自のセッションハンドリングはなるべく控え、 symfony や OpenPNE の用意する機構に則ってセッションハンドリングをおこなうようにしてください。

Session Fixation
++++++++++++++++

Session Fixation とは、攻撃者の発行したセッション ID を被害者のセッションデータと紐付けさせ、利用させる攻撃です。セッション ID を被害者に使用させるということは、攻撃者はセッション ID を知っていることになるわけですから、 Session Hijaking と同様に致命的な脆弱性となります。 Session Fixation を防ぐためには、ログインなどの機会に、新しくセッションを発行し、これまでのセッションを無効にし、新しいセッション ID しか利用しないようにする必要があります。

OpenPNE では symfony のフラッシュ機能 (エラー遷移時などに、エラーメッセージをセッションデータとして記録しておき、次に遷移したページにそのセッションデータに含まれるメッセージの表示等をする機能) を利用するために、ログイン前でもセッションを発行しています。仮にログイン時にセッションを発行し直さなかった場合、ログイン後、そのセッション ID にメンバー ID などの情報が紐づけられることになります。しかし、このログイン前のセッション ID が、実は攻撃者が発行したものであった場合、攻撃者もそのセッション ID を利用してアクセスすることで、ログインしたユーザとして操作をおこなうことができてしまいます。

Cookie 内のセッション ID を用いる場合、この攻撃の難易度は相当高いものとなりますが、手法がないわけではありません。攻撃者がユーザに自分の使用したセッション ID を使わせる手法として、多くの Web ブラウザに存在する Cookie Monster バグ (セカンドレベルドメインが ccSLD であるものであっても、セカンドレベルドメインに対して Cookie を発行できてしまうバグ。つまり、 .co.jp といったドメインに対して Cookie を発行できてしまうというもの) を使用するというものがあります。また、 URL 内にセッション ID を含む方式の場合、 Session Fixation に脆弱なサイトだと、攻撃者の意図したセッション ID を含む URL をユーザに踏ませ、ユーザがそのままログインしてしまうことで攻撃が成立してしまいます。

symfony や OpenPNE によって抽象化されたセッションハンドリング機構では、新しくセッションを発行する際に、セッション ID を生成しなおしています。ですので、 Session Fixation の観点からも、抽象化されたセッションハンドリング機構を利用するようにしてください。

.. ブルートフォースアタックを回避する
.. ----------------------------------

重要な操作における再認証
------------------------

メールアドレス変更、パスワード変更、携帯電話個体識別番号変更といったような認証にかかわる設定変更や、退会処理、そのほかサイトにとって重要な操作をおこなう場面では、必ず再認証もしくはパスワードの入力を要求するようにしてください。

セッション管理の不備や、後述する XSS (Cross Site Scripting) などによってなりすましログインがおこなわれてしまった場合でも、重要な操作をおこなうまえに再認証を要求すれば、認証情報が知られない限りはその操作をおこなうことができないわけですから、原状回復が不可能な被害をある程度抑えることができます。

ただし、携帯電話個体識別番号を用いた認証をおこなっている場合は、必ずパスワードも要求するようにしてください。これは、携帯電話個体識別番号という公開情報のみによる認証自体がそもそも脆いものであり、秘密情報ではないため、これだけでは先に述べた目的を果たせないためです。

.. パスワード文字列生成のヒント
.. ----------------------------

正しく入力値を検証する
======================

サーバサイドでの入力値検証
--------------------------

入力値検証には、必要に応じてフォームフレームワークの利用や、フォームフレームワークで使われる sfValidator* 系のクラス (もしくは OpenPNE 側でそれらのクラスを継承しているもの) などを利用するようにしてください。場合によっては日時や数値など、アプリケーションが期待する変数型や文字列の形式への変換も実施してください。

ただし、たとえば入力値検証において、後述する XSS (Cross Site Scripting) や SQL Injection といった脆弱性への対応を目的として、文字列を前もってエスケープしてしまうといったことがないようにしてください。これは典型的な「誤ったセキュリティ対策」と呼ばれるものです。文字列をどのようにエスケープするべきかは、その文字列がどの文脈で用いられるかによって変化します。それを入力の段階から明確にすることは難しいですし、当初の実装時点ではその入力値が特定の文脈でしか使われていなかったとしても、今後変更されるかもしれません。

ホワイトリストやブラックリストの利用
++++++++++++++++++++++++++++++++++++

ホワイトリストを使用した入力値検証については可能な限り積極的におこなうようにしてください。ホワイトリストにより入力値をプログラムが期待するもののみに限定できます。

これは、特に、ユーザ入力値をエスケープすることによる脆弱性の回避などが困難なケースなどで有効です。

ブラックリストも有用ですが、漏れが生じる危険がありうることを考えると、そのブラックリストはセキュリティ対策としては満足なものでないかもしれません。ホワイトリストのほうがブラックリストよりも確実であるということは認識してください。もし少量の変更でブラックリストからホワイトリストに置き換えることができる場合は置き換えを検討するべきです。

Null Byte Attack による制限の回避への対策
+++++++++++++++++++++++++++++++++++++++++

PHP には、「バイナリセーフである関数」「バイナリセーフでない関数」が混在しています。このうち、「バイナリセーフでない関数」を使用して入力値に対するバリデーションをおこなったつもりでも、 Null Byte Attack として知られる攻撃によって突破されてしまう可能性があります。

ヌル文字は、 C 言語では文字列の終端として認識される文字です。 PHP は C 言語で記述されているため、 PHP 内部の関数などがヌル文字の含まれた文字列をそのまま C 言語の文字列として処理してしまうと、ヌル文字の登場した箇所を文字列の終端としてしまうために、意図した動作をしなくなる可能性があります。ヌル文字を文字列の終端としてしまう、バイナリデータが含まれる文字列を考慮していない関数を「バイナリセーフでない関数」と呼びます。逆に、ヌル文字を文字列の終端とはみなさない、バイナリデータが含まれる文字列を考慮した関数を「バイナリセーフである関数」と呼びます。

「バイナリセーフである関数」を用いて入力値をチェックしたのちに「バイナリセーフでない関数」を使用して処理をおこなうか、「バイナリセーフでない関数」を用いて入力値をチェックしたのちに「バイナリセーフである関数」を使用して処理をおこなった場合、チェックした文字列と実際に処理する文字列が異なることになるわけですから、意図しない動作になる可能性が出てきます。

Null Byte Attack を利用して制限を回避し、脆弱性が成立した例として、以下のようなものがあります。

phpBB "avatar_path" PHP Code Execution Vulnerability:
  http://secunia.com/advisories/22188/

OpenPNE では、例外的に、リクエスト中のヌル文字のみ除外して opWebRequest クラスのインスタンスに渡しています。そのため、 opWebRequest を経由してリクエストパラメータを取得すると、ヌル文字が除去された文字列が得られることになります。これは、 PHP でバイナリセーフである関数とバイナリケースでない関数がすべて明確に示されているわけではなく、常にその関数がバイナリセーフかどうかを確認しながら関数を使用するのは困難なことと、 OpenPNE が Web アプリケーションであり、ヌル文字を意図的に受け入れるべき機会は少ないことなどが理由です。

ただし OpenPNE は $_POST, $_GET, $_REQUEST, $_COOKIE などのスーパーグローバル変数を直接変更することはしないようにしているため、 opWebRequest 経由ではなく直接スーパーグローバル変数にアクセスすることで、ヌル文字が除去されていない文字列を取得することができます。意図してヌル文字を含んだ文字列を取得したい場合は、スーパーグローバル変数に直接アクセスしてください。一方で、ヌル文字を含んだ文字列を取得する必要がなく、その文字列をバイナリセーフでない関数の引数として扱ってしまう可能性がある場合は、 opWebRequest 経由でのアクセスに切り替えるか、自分でヌル文字を取り除くように変更するようにしてください。

クライアントサイドでの入力値検証
--------------------------------

JavaScript などを使用したクライアントサイドでの入力値検証は、セキュリティ対策としては意味をなしません。それは JavaScript などを無効にしたり、 Web サーバに対して直接リクエストを投げることで回避が可能だからです。

クライアントサイドでの入力値検証は、ユーザの利便性を高める目的だけにとどめ、決して頼り切ってはいけません。サーバ側ではクライアントサイドでおこなっているものと同等以上の入力値検証をかならず実施してください。

安全に HTML レスポンスを生成する
================================

XSS (Cross Site Scripting) 脆弱性
---------------------------------

XSS とは、攻撃者がウェブページに任意のコード (多くの場合は JavaScript) を挿入することのできる脆弱性です。

挿入されたコードは被害者のブラウザ上で実行されます。そのため、そのサイトにおいてクライアントがおこなうことのできる操作のほとんどを実行させることができます。

この脆弱性は、ユーザ入力値などの信頼できないデータを含む Web ページを動的に生成する際に、たとえば、その入力値が直接 HTML の構造に作用してしまう形で埋め込んだ場合などに発生します。

たとえば、以下のサンプルコードでは、 GET パラメータの name の値を HTML の一部として出力しています::

  <?php echo '<p>Hello, '.$_GET['name'].'!</p>';

このソースコードは、 `http://example.com/?name=Ebihara` のようにアクセスした場合に、以下のように出力されることを意図したものです::

  <p>Hello, Ebihara!</p>

しかし、 `http://example.com/?name=%3Cstrong%3EEbihara%3C/strong%3E` のようにして、入力値に HTML タグを含めてしまうと、この HTML がそのまま出力に挿入されてしまいます。これは、任意のスクリプトを挿入可能な状態にあるということを意味します::

  <p>Hello, <strong>Ebihara</strong>!</p>

HTML タグをそのまま反映させることを意図しているのでない限り、本来は以下のように出力されなければなりません::

  <p>Hello, &lt;strong&gt;Ebihara&lt;/strong&gt;!</p>

この例のように HTML にユーザ入力値を埋め込む場合の XSS への対策方法はよく知られていますが、動的に生成する JavaScript や画像、 Flash などの Web ブラウザが実行可能なコンテンツすべてについても、この脆弱性への対策を施す必要があります。

XSS による脅威
--------------

JavaScript などによってユーザのブラウザが実行可能なほとんどの操作をおこなうことができます。

もし XSS に脆弱であれば、マルウェアの配布サイトにユーザを連れて行ったり、ページ上に表示されている機密情報を流出させたりといったことができます。セッションクッキーを盗むこともできるので、攻撃者はユーザになりすましてログインすることもできます。

また、フィッシングの手口と組み合わせることで、攻撃者にユーザのパスワードを知られてしまう危険性が向上します。

非常に緊急度の高い脆弱性ですので、発覚してしまった場合は即座に対策を施すべきです。

HTML の生成
-----------

HTML の利用を制限したい入力値にある HTML 特殊文字 (&, <, >, ", ') を、出力時にエスケープする必要があります。

特殊文字が文字参照になるように適切にエスケープが施されていれば、特殊文字を利用して HTML の要素の内容に埋め込まれた入力値から HTML の構造を変更させることで XSS 攻撃を成立させることはできなくなります。

symfony のアクションを通じてテンプレートに渡された値は、明示的に無効にしていない限り、この文字参照へのエスケープの処理が自動的におこなわれます。

たとえば、以下のようなアクションを考えます::

  <?php
  
  class exampleActions extends sfActions
  {
    public function executeIndex(sfWebRequest $request)
    {
      $this->name = $request['name'];
    }
  }

アクションの $name プロパティに値を代入したことで、この $name の値をテンプレートから参照できるようになりました。

このときのリクエストパラメータ name の値が `<strong>Ebihara</strong>` だったとして、以下のようにしてテンプレートから出力しても、結果は正しくエスケープされた状態になります::

  <p>Hello, <?php echo $name ?>!</p>
  /* Output: <p>Hello, &lt;strong&gt;Ebihara&lt;/strong&gt;!</p> */

実はテンプレートからアクセスできる $name の値は、エスケープ済みの文字列というわけではありません。 symfony のアクションを介してテンプレートに変数をアサインすると、その変数の値は sfOutputEscaper でラッピングされます。ですので、アクションからテンプレートに渡された変数は、特別に許可された一部のクラスインスタンスを除き、実際には sfOutputEscaper およびその派生クラスのインスタンスになります。 sfOutputEscaper についての詳細は symfony の http://www.symfony-project.org/gentle-introduction/1_4/en/07-Inside-the-View-Layer#chapter_07_output_escaping を参照してください。

sfOutputEscaper のインスタンスは、アクションから渡された生の値を保持しており、 echo や . 演算子、関数などにより文字列として扱われると、保持している生の値をエスケープして返します。

これにより変数内の HTML 特殊文字のエスケープは適切におこなわれるようになりましたが、 HTML 属性値としてユーザ入力値を出力しようとする際に脆弱になることがあります::

  <p id=<?php echo $name ?>>Hello, <?php echo $name ?>!</p>

このとき $name の生の文字列が `Ebihara onmouseover=alert(0);` だった場合、以下のように p 要素の属性値が追加されてしまい、マウスカーソルを合わせるとスクリプトが実行されてしまいます::

  <p id=Ebihara onmouseover=alert(0);>Hello, Ebihara onmouseover=alert(0);!</p>

" や ' は sfOutputEscaper によってエスケープされるので、このようなケースでは、以下のように属性値を引用符で囲うことで、属性値を超えて入力値が反映されることはなくなります::

  <p id="Ebihara onmouseover=alert(0);">Hello, Ebihara onmouseover=alert(0);!</p>

引用符は ' でも構いませんが、 PHP において HTML 特殊文字のエスケープに用いられる htmlspecialchars() 関数は、第二引数に ENT_QUOTES を与えない限り ' をエスケープしないため、 ' がエスケープされていない状態の入力値が ' で囲まれた属性値として埋め込まれた場合に脆弱になります。 OpenPNE のデフォルト設定では sfOutputEscaper は ENT_QUOTES つきで htmlspecialchars() をコールしますが、原則として引用符には " を使用するべきです。

ただし、この対策をしても以下のような場合は依然として脆弱なことがあるので注意してください (対策方法は後述します)。

 * イベントハンドラを記述するような属性値 (onclick や onmouseover など) に入力値を埋め込む場合 (JavaScript を記述可能)
 * style 要素の内容に入力値を埋め込む場合
 * 任意の要素の style 属性値に入力値を埋め込む場合 (CSS を記述可能)
 * a 要素の href 属性値に入力値を埋め込む場合 (javascript: スキームで任意の JavaScript を記述可能)
 * img 要素の src 属性値に入力値を埋め込む場合 (javascript: スキームで任意の JavaScript を記述可能)

JavaScript の生成
-----------------

JavaScript に動的な値を埋め込む場合、 \\ を付加することによって特定の文字をエスケープをすることがあります。

しかしながら、すべての Web ブラウザで安全なスクリプトを構築するためにはどのような文字をエスケープするべきなのかが明確ではありませんし、攻撃者はエスケープされそうな文字に対してさらに \\ を付加することで、この対策を回避しようとすることがあります。そのため、エスケープに漏れが生じる可能性があります。

たとえば、 script 要素中に JavaScript を記述する場合、 </ が <\\/ となるようにエスケープしなければなりません。ブラウザは </script> 等が出現した場所までを script 要素の内容とみなすためです。

以下の場合、 $_GET['example'] に対して、 symfony で用意されている esc_js_no_entities() ヘルパー関数を用いて、 JavaScript としてのエスケープをおこなっていますが、 esc_js_no_entities() ヘルパー関数は </ を適切にエスケープしないために、リクエストパラメータの値が `</script><script>alert(/XSS/.source); //` というようになっている場合、任意のスクリプトが実行できてしまいます。 Web ブラウザが最初に HTML をパースする際には </script> が JavaScript の文字列中かどうかというようなことは考慮しないためです::

  <script type="text/javascript"><![CDATA[
  var example = "<?php echo esc_js_no_entities($_GET['example']); ?>";
  //]]></script>

そのため、 JavaScript に動的な値を文字列として埋め込む場合は、正確に対処することが難しい \\ によるエスケープではなく、以下のどちらかの手段を用いることを強く推奨します。

 1. 英数字以外の文字を `Unicode エスケープシーケンス`_ (\\uHHHH) に置換する。
 2. HTML 要素の属性値や内容として動的な値を挿入し、 JavaScript から DOM を用いてその値を純粋な JavaScript の文字列として取ってくる。

特に、 2. の方法を用いることを推奨します。以下に例を示します::

  <input id="example" type="hidden" value="<?php echo $name ?>" />
  
  <script type="text/javascript"><![CDATA[
  alert(document.getElementById("example").value);
  //]]></script>

この方法であれば、 HTML の作法に基づいて動的に生成した値を埋め込み、 JavaScript からそれを文字列として取得するだけで済むので、動的に埋め込まれた値は常に JavaScript の文字列のまま保たれることになり、危険は生じえません。

.. _Unicode エスケープシーケンス: http://wiki.ecmascript.org/doku.php?id=spec:chapter_6_lexical_structure&s=unicode#unicode_escapes

CSS の生成
----------

CSS プロパティの値には Internet Explorer の expression() 関数などを利用してスクリプトを埋め込むことができます。ですので、 CSS に入力値を埋め込む場合も適切な配慮が必要になります。

一般に \\ を前置することによる特定の文字のエスケープがおこなわれることがありますが、 JavaScript の場合と同様、避けるべきです。

`CSS では、バックスラッシュに続けて 16 進数字を連続させることで、そのコードポイントに位置する Unicode の文字を表現することができます。`_ これを利用し、英数字以外のすべての文字をこのような 16 進表現に置換することで、安全にその文字列を値として利用することができるようになります。

しかしながら、管理画面からの入力を除いて、入力値に基づいて CSS を生成することはなるべく回避することをお勧めします。

.. _CSS では、バックスラッシュに続けて 16 進数字を連続させることで、そのコードポイントに位置する Unicode の文字を表現することができます。: http://www.w3.org/TR/CSS21/syndata.html#characters

画像の生成
----------

Internet Explorer では、レスポンスヘッダ内の Content-Type のみならず、コンテンツの中身も確認した上で、最終的にそのレスポンス内容をどのような種類のコンテンツとして処理するべきか決定します。

たとえば、 Content-Type が image/gif であっても、レスポンスの内容が HTML であれば text/html として読み込んでしまいます。 (CAPEC-209: Cross-Site Scripting Using MIME Type Mismatch http://capec.mitre.org/data/definitions/209.html)

HTML として読み込まれた画像に JavaScript が埋め込まれていれば、ブラウザは当然にその JavaScript を実行してしまい、 XSS 脆弱性が成立してしまいます。

OpenPNE ではユーザのアップロードした画像を表示するために sfImageHandlerPlugin を用意しています。このプラグインで処理された画像は、一度 GD を通して画像を生成し直した上で表示されることになるため、画像以外の情報は除去された状態になり、安全に画像を表示することができます。

ユーザの画像アップロードを許す場合、その画像をそのまま表示するということはせずに、 sfImageHandlerPlugin もしくは他の手段を用いてから表示するようにしてください。

X-Content-Type-Options レスポンスヘッダ
+++++++++++++++++++++++++++++++++++++++

Internet Explorer 8 以降では、 `X-Content-Type-Options: nosniff` というレスポンスヘッダを送信された場合に、サーバ側から送信された Content-Type のみを確認してファイルタイプを決定するようになるため、前述の CAPEC-209 の攻撃を無効化することができます。

Internet Explorer 8 未満ではこのヘッダは導入されていないため、前述のような対策は怠るべきではありませんが、脆弱性があった場合にターゲットとなるブラウザを最小限に食い止めるために、動的に生成されるなるべく多くのコンテンツでこのレスポンスヘッダを送信するようにしておくことを推奨します。

DOM Based XSS の回避
--------------------

JavaScript の機能のなかには、 document.write() や innerHTML など HTML 表現を出力するものがあります。これらの出力に動的に変化する値を含んでいると、 XSS となる場合があります。サーバソフトウェアを介さずにクライアント側で完結する XSS 攻撃を、一般に、 DOM Based XSS と呼びます。

たとえば、以下のようなコードは DOM Based XSS に脆弱です::

    document.write("<p>Hello, "+document.location.hash+"!</p>");

このようなコードを持つリソースに対して http://example.com/#Ebihara という URL でアクセスすると、ブラウザは以下のように出力します::

    <p>Hello, Ebihara!</p>

しかし、 `http://example.com/#%3Cstrong%3EEbihara%3C/strong%3E` のようにして、入力値に HTML タグを含めてしまうと、この HTML がそのまま出力に挿入されてしまいます::

  <p>Hello, <strong>Ebihara</strong>!</p>

対策としては、 innerHTML や outerHTML、 document.write() や document.writeln() といった HTML 表現の出力をおこなう機能を使用しないようにするのが確実です。それが難しい場合、出力する文字列を JavaScript ライブラリの機能を用いてエスケープしてください。

.. 文脈にあったエスケープを心がける
.. --------------------------------

安全に SQL を生成する
=====================

HTML の生成と同様、 SQL の生成にあたっても、ユーザ入力値など信頼できない値の取り扱いには注意が必要です。

ユーザ入力値を含んだ SQL 文を動的に生成する場合、その入力値によって、最終的に実行される SQL の構文を意図したものと違うものに変更されてしまう可能性があります。

これは SQL Injection と呼ばれている脆弱性です。この脆弱性が存在していると、攻撃者にデータベースに存在する情報の漏洩や改ざんを許してしまいます。

たとえば、以下のようなコードは SQL Injection に対して脆弱です::

  <?php
  // $pdo は PDO のインスタンス
  $pdo->query(sprintf('SELECT * FROM user WHERE username = "%s" AND password = "%s";', $_GET['username'], $_GET['password']));

`http://example.com/?username=jsmith&password=example` のような URL にアクセスがあった場合、このコードの意図通りに、以下の SQL 文が生成され、実行されます::

  SELECT * FROM user WHERE username = "jsmith" AND password = "example";

しかし、 `http://example.com/?username=jsmith%22;%20--%20&password=whatever` のような URL にアクセスすると、以下のクエリが実行されてしまいます (`--` 以降はコメント) ::

  SELECT * FROM user WHERE username = "jsmith"; -- " AND password = "whatever";

また、複数文の発行が許可されている場合には、 `http://example.com/?username=%22;%20DELETE%20FROM%20user;%20SELECT%20username%20AS%20dummy%20FROM%20user%20WHERE%20%22%22%20%3D%20%22&password=whatever` のような URL にアクセスされると、以下のように DELETE 文が発行されてしまいます::

  SELECT * FROM user WHERE username = "";
  DELETE FROM user;
  SELECT username AS dummy FROM user WHERE "" = "" AND password = "whatever";

OpenPNE で SQL Injection に対処するには、バインド機構を使用して SQL 文を生成するようにするのが一番よい解決方法です。

バインド機構とは、実際の値を埋め込む場所を記号 (プレースホルダ) で示した SQL 文をあらかじめ準備しておき、後からプレースホルダを実際の値に置き換えて SQL を構築する機構のことをいいます。バインド機構はプレースホルダから実際の値に置き換えるときに、実際の値を正しくエスケープします。

PDO はバインド機構に対応しているので、先に示したサンプルコードを以下のように変更することで、 SQL Injection からアプリケーションを守ることができます::

  <?php
  // $pdo は PDO のインスタンス
  $sth = $pdo->prepare('SELECT * FROM user WHERE username = ? AND password = ?;');
  $sth->execute(array($_GET['username'], $_GET['password']));

OpenPNE においては、自分で SQL 文を生成するすべての箇所で SQL Injection に対して配慮をおこなわなければなりません。 OpenPNE ではほとんどの場合直接 SQL 文を書かずに、 Doctrine の DQL 文を直接記述もしくは構築し、その DQL を SQL に変換して実行するということをおこなっていますが、 この DQL も以下のように誤った形で組み立ててしまうと、結局、 SQL Injection に脆弱になってしまいます::

  <?php
  Doctrine::getTable('User')->createQuery()
    ->where(sprintf('username = "%s" AND password = "%s"', $_GET['username'], $_GET['password']))
    ->execute();

このコードは、バインド機構を利用して DQL を組み立てるために、以下のように記述するべきです::

  <?php
  Doctrine::getTable('User')->createQuery()
    ->where('username = ? AND password = ?', array($_GET['username'], $_GET['password']))
    ->execute();

一方で、たとえば Doctrine_Table::find() メソッドに関しては、 SQL Injection に対して配慮して SQL 文が生成されるため、引数を渡す際に特別な配慮をおこなう必要はありません。ですが、 Doctrine_Table::findBySql() や Doctrine_Table::findByDql() といった SQL や DQL を自分で組み立てるようなメソッドを利用する場合には、やはり、 SQL Injection に対する配慮が求められることになります。

自分で SQL や DQL を組み立てる必要があり、 SQL Injection に対する配慮が必要なものとしては、たとえば以下のようなものがあります。

 * PDO 以外のデータベース関連拡張が提供する関数群
 * PDO::exec() や PDOStatement::execute() などクエリを実行する PDO のメソッド
 * Doctrine_Connection::fetchAll() など直接 SQL を実行する Doctrine_Connection のメソッド
 * Doctrine_RawSql
 * Doctrine_Query
 * Doctrine_Table::findBySql() など、自分で作成したクエリを元にレコードを取得するようなメソッド

また、バインド機構を利用したとしても、ユーザ入力値に基づいてカラム名などを動的に組み立てるような場合は、 SQL Injection に対して脆弱となります。できるだけそのようなコードは控えるようにするべきですが、それが難しい場合、必ず、動的に組み立てる箇所に対してエスケープやクオート処理を実施してください。

エスケープ等に使用できる Doctrine のメソッドとしては以下のようなものがあります。エスケープ等が必要な記号群やエスケープ手法などはデータベースエンジンによって異なります。そのため、独自処理を施すより、 Doctrine が用意しているメソッドを利用しておこなうことを強く推奨します。

 * Doctrine_Formatter::escapePattern()
 * Doctrine_Connection::quote()
 * Doctrine_Connection::quoteIdentifier()

安全に外部コマンドを実行する
============================

PHP には外部コマンドを実行可能ないくつかの関数が存在しますが、極力、それらの使用は避けてください。仮に任意の外部コマンドを実行することができる脆弱性 (一般的には OS コマンドインジェクション脆弱性と呼ばれます) が存在してしまっていると、サーバ内ファイルへのアクセスやシステムの操作など非常に多くの、そして危険度の高い脅威が発生しえます。

他の手段で代替することができず、どうしても実行する外部コマンドをユーザ入力値を利用して構築しなければならない場合、ホワイトリストを用いて実行するべきコマンドをできる限り固定なものにしてください。それも難しい場合、 escapeshellarg() や escapeshellcmd() を使いエスケープしてください。加えて、その入力値の要件にあった適切な入力値検証、フィルタリング (数値文字列を整数型変数に変換するなど) といった保険的な対策をもれなくおこなっておくことを強く推奨します。

意図しないファイルへのアクセスを防ぐ
====================================

以下のような、ユーザ入力値を含んだテンプレートファイルへのパスを構築し、そのファイルを読み込むコードを考えます::

  <?php
  
  echo file_get_contents('/path/to/template/'.$_GET['name']);

name パラメータの値が hello の場合、 /path/to/template/hello の内容が出力されます。しかし、パラメータの値に ../../../etc/passwd を入力すると、読み込むべきファイルは /path/to/template/../../../etc/passwd となり、 /etc/passwd の内容が出力されてしまいます。このように任意のファイルへのアクセスを許してしまう脆弱性のことを、一般に、ディレクトリトラバーサル脆弱性、または、パストラバーサル脆弱性などと呼んでいます。

また、ユーザ入力値を基に任意のファイルを書き込むような場合、このディレクトリトラバーサル脆弱性が存在していると、ウェブの公開ディレクトリ直下にそのファイルを書き込むようにリクエストし、できあがったファイルにアクセスするようユーザを案内することで XSS を発生させる、といったような危険もあります。

ファイルにアクセスする場合には、ユーザ入力値などの信頼できない値を用いてファイル名を指定するような実装は避けるようにしてください。どうしてもそのような実装をしなければならない場合、ディレクトリ名は固定とし、ユーザ入力値によって変更できない状態にしたうえで、 basename() 関数をユーザ入力値に対して使い、ファイル名のみを取り出し、この値を基にファイルパスを組み立ててください。

ビューキャッシュ保存におけるディレクトリトラバーサル脆弱性についての注意
------------------------------------------------------------------------

ビューキャッシュを保存する際に、そのキャッシュを一意に特定するためにキャッシュキーを明示的に指定する場合がありますが、このキャッシュキーに信頼できないユーザ入力値を検証せずに使ってしまわないよう注意する必要があります。

ビューキャッシュに sfFileCache を使用する設定 (デフォルト) になっている場合で、パーシャルキャッシュ (コンポーネントキャッシュ) をおこなう際に sf_cache_key パラメータを指定しているとき、 symfony はその値をファイル名として使用しようとします。 sf_cache_key に 使用される値に信頼できないユーザ入力値を利用している場合、ディレクトリトラバーサル攻撃に脆弱となります。

symfony 1.4.6 において、 http://www.symfony-project.org/blog/2010/06/29/security-release-symfony-1-3-6-and-1-4-6 で発表されているように、この問題と類似の、ビューキャッシュを利用したディレクトリトラバーサル脆弱性が修正されていますが、 symfony 1.4.6 で修正された問題は「アクションの結果全体に対するビューキャッシュで、信頼できない GET パラメータの値に応じてキャッシュキーを生成している」というもので、ここで解説している問題とは異なります。つまり、 symfony 1.4.6 以降を使用している場合であっても、パーシャルキャッシュをおこなう際に指定するキャッシュキーを、未検証のユーザ入力値を利用したものにしないように注意していかなくてはなりません。

SNS 内情報を安全な形で保存する
==============================

SNS の情報は安全な形で保存するように心がけてください。

まず、 SQL Injection 攻撃を受けてしまい、データベースの情報が漏洩してしまったときのために、パスワードなどの情報は salt 付きでハッシュ化してください。また、可能な限りハッシュアルゴリズムには SHA-1 や MD5 よりも SHA-256 や SHA-512 を用いることを推奨します。 SHA-1 や MD5 はクラック手法が発見されてしまっているためです。

XSS 対策としてユーザ入力値を HTML エンコーディングしたうえで DB に格納するといったことも控えてください。アプリケーションで後からこの値を使う際に、その値は入力値として扱われるので、先に述べたとおり、入力時点でのエスケープという「誤ったセキュリティ対策」をしていることになります。入力が HTML エンコーディングで固定されてしまっており、元の値を取得する手段がないとなると、開発者は、この HTML エンコーディングされた文字列を元に戻そうとする (アンエスケープしようとする) ようになることでしょう。ここで、誤ったアンエスケープをしようとして、手違いにより XSS に脆弱な箇所を生んでしまうといった危険が生じ得ます。

アクセス権限の制限の回避を防ぐ
==============================

CSRF (Cross Site Request Forgeries) 脆弱性
------------------------------------------

CSRF 脆弱性は、ユーザに意図しないリクエストを発生させることを強いることができる脆弱性です。

罠が仕掛けられた、そのサイト内あるいはサイト外のページにおいて、 CSRF 脆弱性を悪用したリクエストを発生させるような動作 (リンクのクリックやフォームの送信など) をユーザがおこなうことで、意図しない投稿や設定の変更などを強制的におこなわされてしまいます。

たとえば、 `http://example.com/example/{id}/delete` という URL (id は単純な連番で予測可能なものであるとします) に対して POST リクエストをおこなうことで、 example の削除処理がおこなわれるという場合、リクエストはたとえば以下のようになります::

  POST /example/1/delete HTTP/1.1
  Host: example.com
  Cookie: PHPSESSID=754d3b148df7a597947f5556cbe06628
  Content-Type: application/x-www-form-urlencoded
  Content-Length: 0
  

このリクエストには Cookie の値を除き、秘密情報はどこにも含まれていません。ですので、 /example/1/delete という URL に POST リクエストを実行させれば削除処理をおこなわせることができる、ということが知られてしまえば、ユーザがこの POST リクエストを発行するようなフォームを罠ページなどで実行してしまうことで、ユーザは意図せずに example を削除してしまうことになります。このリクエストを受けてアプリケーション側で削除処理を実行してしまってはいけません。

そこで、リクエストに秘密情報を要求するようにすることで、 CSRF を防ぐことができます。リクエストに秘密情報を含める対策の例として、以下のようなものがあります。

 1. セッション ID を hidden フィールドの値として入れるなどしてリクエストに含む
 2. ユーザのパスワードを入力させる
 3. 独自の予測不可能な ID を hidden フィールドの値として入れるなどしてリクエストに含む

一般に用いられるのは 1. もしくは 3. です。 OpenPNE では 1. に基づいた 3. を、この後に説明するフォームフレームワークの機構を用いて生成することにより対策してください。

ただし、 1. や 3. の場合、そのサイト内に XSS 脆弱性が存在する場合、容易に回避することが可能になります。そのため、本当に重要な操作については、 2. の対策もあわせて実施することを強く推奨します。

フォームにおける対策
++++++++++++++++++++

symfony のフォームフレームワークを利用してフォームのレンダリングやリクエストのバリデーションをおこなうことで、結果的に CSRF を防ぐことができます。ですので、フォームを記述する際はフォームフレームワークを利用して書くようにしてください。

sfForm およびその派生クラスは、「OpenPNE.yml で設定できる csrf_secret の値 (デフォルト値は設定ファイルのタイムスタンプ)」と、「セッション ID」、そして「そのフォームのクラス名」を文字列連結したものの MD5 ハッシュ値を、 CSRF トークンとして提供します。

この CSRF トークンがリクエスト中に含まれているかどうかをもって、フォームクラスが適切なリクエストかどうかを判断します。

フォームフレームワークについては http://www.symfony-project.org/gentle-introduction/1_4/ja/10-Forms を参照してください。

なお、この CSRF 保護の機構を無効にする手段がいくつか存在します。これは、 CSRF への対策の必要がない種類の操作 (たとえば、実行してもユーザや SNS 内データに影響しない操作) などにおいて、 CSRF トークンのチェックが邪魔になるようなときに有用ですが、 CSRF 保護の機構を無効にする場合は充分によく考えてから実施するようにしてください。

アクション内での対策
++++++++++++++++++++

フォームを使用しないアクションであっても、 CSRF 対策が必要な場合にはフォームフレームワークを使用して対処することができます。

まず、リクエストをする側のアクションもしくはテンプレートで、 BaseForm (sfForm の派生クラスで、プロジェクトのほとんどのフォームの親クラス) のインスタンスを生成し、普段フォームフレームワークを使用するのと同じように BaseForm をレンダリングします。

フォームによってリクエストを実行したくない場合は、リクエストパラメータに BaseForm のインスタンスから得られる CSRF トークンを含めるように明示的に指定する必要があります。パラメータ名は BaseForm::getCSRFFieldName()、 CSRF トークンの値は BaseForm::getCSRFToken() で取得できます。

リクエストを処理する側のアクションでは、以下のように sfWebRequest::checkCSRFProtection() を実行するだけで、 CSRF トークンのチェックをおこなうことができます::

  <?php
  
  class exampleActions extends sfActions
  {
    public function executeDelete(sfWebRequest $request)
    {
      $request->checkCSRFProtection();
    }
  }

sfWebRequest::checkCSRFProtection() は、正しい CSRF トークンがリクエストに含まれている場合は何もしません。リクエストに含まれている CSRF トークンに問題があるか、存在しない場合 sfValidatorErrorSchema のクラスインスタンスを例外として throw します。

この例外はアクションを実行している opExecutionFilter によって透過的に catch し、適切なエラーメッセージを出力するので、アクション側で catch をするなどして特別な配慮をおこなう必要はありません。

Ajax リクエストにおける対策
+++++++++++++++++++++++++++

うっかり忘れがちなことですが、 Ajax リクエストにおいても、 CSRF 対策が必要になる場合があります。

対処方法は「アクション内での対策」と同様、 BaseForm から得られる CSRF トークンの値をリクエストに含むことです。

クライアントサイドでのバリデーション、つまり JavaScript によってポストしようとしている CSRF トークンをチェックするようなことは、セキュリティ上意味をなさないことを念頭に置いてください。必ずサーバサイドでチェックをおこなうようにしてください。

アクションで認証を要求する
--------------------------

単純にアクションを作っただけでは、そのアクションは認証を要求しません。つまり、そのアクションは未ログイン状態のユーザでも実行可能ということになります。

認証を要求するアクションを作りたい場合は、以下のうちどちらか一方の作業をおこなってください。

 1. security.yml を作り、アクション実行前に自動的に認証をおこなうようにする。
 2. アクション内に、自分で認証のためのコードを記述する。

security.yml については http://www.symfony-project.org/gentle-introduction/1_4/ja/06-Inside-the-Controller-Layer#chapter_06_fa99a6d638f334600f0681315182141a32d28123 を参照してください。

権限チェックの漏れを防ぐ
------------------------

メンバーがそのアクションを実行可能な権限を持っているかどうか、もしくはそのアクションで実行される一部の表示要素にアクセスする権限を持っているかどうか、などは必ず念入りに確認をおこなってください。フレンド関係にないのにフレンドのみに公開された情報を閲覧できる、などといったことがないように気を配ってください。

権限チェックは可能な限り共通化してから呼び出すようにし、漏れが生じにくいように徹底してください。

また、 OpenPNE では、いくつかのレコードクラスと Zend_Acl を組み合わせて、そのリソースに対するアクセス権限チェックがおこなえるような仕組みを用意しているので、これを利用することもできます。アクション実行前にリソースへのアクセス権限を有しているかどうかを確認させたい場合は、 opDynamicAclRoute クラスを使ったルーティングルールを記述してください。テンプレート中などで、特定のレコードクラスのインスタンスに対して、現在閲覧中のメンバーがそのリソースにアクセス可能かどうか調べるには、レコードクラスのインスタンスメソッド isAllowed() を使用してください。
